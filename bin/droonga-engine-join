#!/usr/bin/env ruby
#
# Copyright (C) 2014 Droonga Project
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

require "slop"
require "json"
require "pathname"
require "socket"

require "droonga/engine/version"
require "droonga/path"
require "droonga/catalog_fetcher"
require "droonga/catalog_generator"
require "droonga/catalog_loader"
require "droonga/safe_file_writer"
require "droonga/data_absorber"
require "droonga/serf"
require "droonga/node_metadata"

class JoinCommand
  def run
    parse_options
    trap_signals

    puts "Start to join a new node #{@options[:host]}"
    puts "       to the cluster of #{@options["replica-source-host"]}"
    puts "                     via #{@options["receiver-host"]} (this host)"
    puts ""
    puts "Source Cluster ID: #{source_cluster_id}"
    puts ""

    set_node_role
    update_existing_nodes
    do_join
    copy_data unless @options["no-copy"]
    set_effective_message_timestamp
    reset_node_role
    puts("Done.")
    exit(true)
  end

  private
  def parse_options
    options = Slop.parse(:help => true) do |option|
      option.on("no-copy", "Don't copy data from the source cluster.",
                :default => false)

      option.separator("Connections:")
      option.on(:host=,
                "Host name of the new node to be joined.",
                :required => true)
      option.on("replica-source-host=",
                "Host name of the soruce node in the cluster to be connected.",
                :required => true)
      option.on("receiver-host=",
                "Host name of this host.",
                :default => Socket.gethostname)
      option.on(:dataset=,
                "Dataset name of for the node to be joined.",
                :default => Droonga::CatalogGenerator::DEFAULT_DATASET)
      option.on(:port=,
                "Port number of the source cluster to be connected.",
                :as => Integer,
                :default => Droonga::CatalogGenerator::DEFAULT_PORT)
      option.on(:tag=,
                "Tag name of the soruce cluster to be connected.",
                :default => Droonga::CatalogGenerator::DEFAULT_TAG)
      option.on("records-per-second=",
                "Maximum number of records per second to be copied. " +
                  "'#{Droonga::Client::RateLimiter::NO_LIMIT}' means no limit.",
                :as => Integer,
                :default => Droonga::DataAbsorber::DEFAULT_MESSAGES_PER_SECOND)
    end
    @options = options
  rescue Slop::MissingOptionError => error
    $stderr.puts(error)
    exit(false)
  end

  def joining_node
    "#{@options[:host]}:#{@options[:port]}/#{@options[:tag]}"
  end

  def source_node
    "#{@options["replica-source-host"]}:#{@options[:port]}/#{@options[:tag]}"
  end

  def source_cluster_id
    source_catalog.cluster_id
  end

  def source_catalog
    @source_catalog ||= parse_source_catalog
  end

  def parse_source_catalog
    loader = Droonga::CatalogLoader.new
    loader.parse(raw_source_catalog)
  end

  def raw_source_catalog
    @raw_source_catalog ||= fetch_source_catalog
  end

  def fetch_source_catalog
    fetcher = Droonga::CatalogFetcher.new(:host          => @options["replica-source-host"],
                                          :port          => @options[:port],
                                          :tag           => @options[:tag],
                                          :receiver_host => @options["receiver-host"])
    fetcher.fetch(:dataset => @options[:dataset])
  end

  def run_remote_command(target, command, options)
    serf = Droonga::Serf.new(target)
    serf.send_query(command, options)
  end

  def absorber
    @absorber ||= prepare_absorber
  end

  def prepare_absorber
    absorber_options = {
      :dataset          => @options[:dataset],
      :source_host      => @options["replica-source-host"],
      :destination_host => @options[:host],
      :receiver_host    => @options["receiver-host"],
      :port             => @options[:port],
      :tag              => @options[:tag],
      :messages_per_second => @options["records-per-second"],
    }
    Droonga::DataAbsorber.new(absorber_options)
  end

  def set_node_role
    if absorber.source_node_suspendable?
      puts("Changing role of the source node...")
      run_remote_command(source_node, "change_role",
                         "node" => source_node,
                         "role" => Droonga::NodeMetadata::Role::ABSORB_SOURCE)
    end
    puts("Changing role of the joining node...")
    run_remote_command(joining_node, "change_role",
                       "node" => joining_node,
                       "role" => Droonga::NodeMetadata::Role::ABSORB_DESTINATION)
    @node_role_changed = true
  end

  def reset_node_role
    if absorber.source_node_suspendable?
      puts("Restoring role of the source node...")
      run_remote_command(source_node, "change_role",
                         "node" => source_node,
                         "role" => nil)
    end
    puts("Restoring role of the joining node...")
    run_remote_command(joining_node, "change_role",
                       "node" => joining_node,
                       "role" => nil)
    wait_until_restarted(joining_node)
    @node_role_changed = false
  end

  def do_join
    puts("Joining new replica to the cluster...")
    run_remote_command(joining_node, "join",
                       "node"    => joining_node,
                       "type"    => "replica",
                       "source"  => source_node,
                       "dataset" => @options[:dataset])
    wait_until_restarted(joining_node, source_node)
  end

  def copy_data
    puts("Copying data from the source node...")

    @start_time_in_seconds = Time.new.to_i

    run_remote_command(joining_node, "absorb_data",
                       "node"    => joining_node,
                       "source"  => source_node,
                       "port"    => absorber.port,
                       "tag"     => absorber.tag,
                       "dataset" => absorber.dataset,
                       "messages_per_second" => absorber.messages_per_second)

    last_progress = ""
    while true
      sleep(3)
      response = run_remote_command(joining_node, "report_metadata",
                                    "node" => joining_node,
                                    "key"  => "absorbing")
      if response
        absorbing = response["value"]
        break unless absorbing
      end

      progress = absorber.report_progress(@start_time_in_seconds)
      if progress
        printf("%s", "#{" " * last_progress.size}\r")
        printf("%s", "#{progress}\r")
        last_progress = progress
      end
    end
    puts ""
  end

  def set_effective_message_timestamp
    response = run_remote_command(source_node, "report_metadata",
                                  "node" => source_node,
                                  "key" => "last_processed_message_timestamp")
    timestamp = response["value"]
    if timestamp and not timestamp.empty?
      puts "The timestamp of the last processed message in the source node: #{timestamp}"
      puts "Setting effective message timestamp for the destination node..."
      response = run_remote_command(joining_node, "set_metadata",
                                    "node" => joining_node,
                                    "key" => "effective_message_timestamp",
                                    "value" => timestamp)
      wait_until_restarted(joining_node)
    end
  end

  def update_existing_nodes
    puts("Update existing hosts in the cluster...")
    run_remote_command(source_node, "add_replicas",
                       "cluster_id" => source_cluster_id,
                       "dataset" => @options[:dataset],
                       "hosts"   => [@options[:host]])
    wait_until_restarted(source_node)
  end

  def trap_signals
    trap(:TERM) do
      do_cancel
      trap(:TERM, "DEFAULT")
    end

    trap(:INT) do
      do_cancel
      trap(:INT, "DEFAULT")
    end

    trap(:QUIT) do
      do_cancel
      trap(:QUIT, "DEFAULT")
    end
  end

  def do_cancel
    #XXX we have to write more codes to cancel remote processes!
    reset_node_role if @node_role_changed
  end

  def wait_until_restarted(*nodes)
    #TODO: wait for restarting of the given nodes. this should be done more safely.
    sleep(5)
  end
end

JoinCommand.new.run
