#!/usr/bin/env ruby
#
# Copyright (C) 2014 Droonga Project
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

require "optparse"
require "fileutils"
require "yaml"

require "droonga/path"
require "droonga/command/droonga_engine"
require "droonga/safe_file_writer"

options = {
  :quiet => nil,
  :clear => nil,
  :reset_config  => nil,
  :reset_catalog => nil,
}

configuration = Droonga::Command::DroongaEngine::Configuration.new
parser = OptionParser.new
parser.on("--quiet", "Run with no prompt.") do |host|
  options[:quiet] = true
end
parser.on("--clear", "Clear any existing data.") do |host|
  options[:clear] = true
end
parser.on("--reset-config", "Regenerate the configuration file \"droonga-engine.yaml\".") do |host|
  options[:reset_config] = true
end
parser.on("--reset-catalog", "Regenerate the \"catalog.json\".") do |host|
  options[:reset_catalog] = true
end
configuration.add_command_line_options(parser)
parser.parse!(ARGV)


def ensure_have_write_permission
  test_file = Droonga::Path.base + "#{Time.now.to_i}.test"
  begin
    FileUtils.touch(test_file.to_s)
  rescue Errno::EACCES => error
  end
  unless test_file.exist?
    puts("You have no permission to write files under " +
           "<#{Droonga::Path.base.to_s}>.")
    puts("Try again with right permission.")
    exit(false)
  end
  FileUtils.rm_f(test_file.to_s)
end

def service_user_exist?
  system("id", service_user_name,
         :out => "/dev/null",
         :err => "/dev/null")
end

def installed_as_service?
  return false unless service_user_exist?

  succeeded = system("service", "droonga-engine", "status",
                     :out => "/dev/null",
                     :err => "/dev/null")
  return true if succeeded

  result = `env SYSTEMCTL_SKIP_REDIRECT=yes service droonga-engine status`
  result.include?("running") or result.include?("droonga-engine is stopped")
end

def service_user_name
  "droonga-engine"
end

def service_base_directory
  "/home/#{service_user_name}/droonga"
end

def running?(configuration)
  if installed_as_service?
    result = `env SYSTEMCTL_SKIP_REDIRECT=yes service droonga-engine status`
    result.include?("running")
  else
    system("droonga-engine-status",
           "--base-dir", Droonga::Path.base.to_s,
           "--pid-file", configuration.pid_file_path.to_s,
           :out => "/dev/null",
           :err => "/dev/null")
  end
end

def unjoin(configuration)
  system("droonga-engine-unjoin",
         "--host", configuration.host,
         :out => "/dev/null",
         :err => "/dev/null")
end

def stop_service(configuration)
  if installed_as_service?
    system("service", "droonga-engine", "stop",
           :out => "/dev/null",
           :err => "/dev/null")
  else
    system("droonga-engine-stop",
           "--base-dir", Droonga::Path.base.to_s,
           "--pid-file", configuration.pid_file_path.to_s,
           :out => "/dev/null",
           :err => "/dev/null")
  end
end

def start_service
  if installed_as_service?
    system("service", "droonga-engine", "start",
           :out => "/dev/null",
           :err => "/dev/null")
  else
    puts("The droonga-engine service is still stopped.")
    puts("You need to start the service again manually.")
  end
end

def input(message, default_value=nil)
  print "#{message} [#{default_value}]: "
  response = gets.strip
  if response.empty?
    default_value
  else
    response
  end
end

def confirmed?(message)
  while true
    print "#{message} (y/N): "
    response = gets
    case response
    when /\Ay/i
      return true
    when /\An/i, /^$/
      return false
    end
  end
end

def path_from_base_dir(path)
  path = path.to_s
  base = "#{Droonga::Path.base.to_s}/"
  if path.start_with?(base)
    path.sub(base, "")
  else
    path
  end
end


running = false
if running?(configuration)
  if !options[:quiet]
    puts("The droonga-engine service is now running.")
    puts("Before reconfiguration, the service is going to be stopped " +
           "and this node will be unjoined from the cluster.")
    unless confirmed?("Are you sure you want to continue reconfiguration?")
      exit(false)
    end
  end
  running = true
end


Droonga::Path.base = service_base_directory if service_user_exist?

ensure_have_write_permission


data_files = [
  Droonga::Path.databases,
  Droonga::Path.state,
]
have_data = data_files.any?(&:exist?)
options[:clear] = false unless have_data

if !options[:quiet] and options[:clear].nil?
  options[:clear] = confirmed?("Do you want all data to be cleared?")
end


options[:reset_config] = true unless Droonga::Path.config.exist?
if !options[:quiet] and options[:reset_config].nil?
  options[:reset_config] = confirmed?("Do you want the configuration file " +
                                        "\"droonga-engine.yaml\" to be regenerated?")
end

options[:reset_catalog] = true unless Droonga::Path.catalog.exist?
if !options[:quiet] and options[:reset_catalog].nil?
  options[:reset_catalog] = confirmed?("Do you want the file \"catalog.json\" " +
                                         "to be regenerated?")
end


if running
  unjoin(configuration)
  stop_service(configuration)
end

if options[:clear]
  data_files.each do |file|
    FileUtils.rm_rf(file.to_s)
  end
end

if options[:reset_config] or options[:reset_catalog]
  if configuration.have_given_host? or options[:quiet]
    host = configuration.host
  else
    host = input("host", configuration.host)
  end

  if configuration.have_given_port? or options[:quiet]
    port = configuration.port
  else
    port = input("port", configuration.port).to_i
  end

  if configuration.have_given_tag? or options[:quiet]
    tag = configuration.tag
  else
    tag = input("tag", configuration.tag)
  end
end

if options[:reset_config]
  if service_user_exist?
    daemon = true
  elsif configuration.have_given_daemon? or options[:quiet]
    daemon = configuration.daemon?
  else
    daemon = confirmed?("run as a daemon?")
  end

  if service_user_exist?
    log_file = Droonga::Path.default_log_file
  elsif configuration.have_given_log_file?
    log_file = configuration.log_file
  elsif options[:quiet]
    log_file = Droonga::Path.default_log_file
  else
    log_file = input("path to the log file", Droonga::Path.default_log_file)
  end

  if configuration.have_given_log_level? or options[:quiet]
    log_level = configuration.log_level
  else
    log_level = input("log level", configuration.log_level)
  end

  pid_file_path = nil
  unless installed_as_service?
    if options[:quiet] or service_user_exist?
      pid_file_path = Droonga::Path.default_pid_file
    elsif  configuration.have_given_pid_file?
      pid_file_path = configuration.pid_file_path
    else
      pid_file_path = input("path to the PID file", Droonga::Path.default_pid_file)
    end
  end

  new_configuration = {
    "host"      => host,
    "port"      => port,
    "tag"       => tag,
    "daemon"    => daemon,
    "log_file"  => path_from_base_dir(log_file),
    "log_level" => log_level,
  }
  unless pid_file_path.nil?
    new_configuration["pid_file"] = path_from_base_dir(pid_file_path)
  end
  Droonga::SafeFileWriter.write(Droonga::Path.config,
                                YAML.dump(new_configuration))
  if service_user_exist?
    FileUtils.chown(service_user_name, service_user_name, Droonga::Path.config)
  end
end

if options[:reset_catalog]
  system("droonga-engine-catalog-generate",
         "--output", Droonga::Path.catalog.to_s,
         "--hosts",  host,
         "--port",   port.to_s,
         "--tag",    tag)
  if service_user_exist?
    FileUtils.chown(service_user_name, service_user_name, Droonga::Path.catalog)
  end
end

start_service if running

exit(true)
