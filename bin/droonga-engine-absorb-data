#!/usr/bin/env ruby
#
# Copyright (C) 2014 Droonga Project
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

require "ostruct"
require "optparse"
require "socket"
require "coolio"

require "droonga/engine/version"
require "droonga/catalog_generator"
require "droonga/path"
require "droonga/data_absorber"
require "droonga/serf"
require "droonga/client"
require "droonga/node_metadata"
require "droonga/restarter"

class AbsorbDataCommand
  def run
    @loop = Coolio::Loop.default

    parse_options
    assert_valid_options
    trap_signals

    puts "Start to absorb data from #{@options.source_host}"
    puts "                       to #{@options.destination_host}"
    puts "                      via #{@options.receiver_host} (this host)"
    puts "  dataset = #{@options.dataset}"
    puts "  port    = #{@options.port}"
    puts "  tag     = #{@options.tag}"
    puts ""
    puts "Absorbing..."

    succeeded = absorb

    puts "Done." if succeeded
    exit(succeeded)
  end

  private
  def parse_options
    options = OpenStruct.new
    options.port    = Droonga::CatalogGenerator::DEFAULT_PORT
    options.tag     = Droonga::CatalogGenerator::DEFAULT_TAG
    options.dataset = Droonga::CatalogGenerator::DEFAULT_DATASET
    options.receiver_host = Socket.gethostname
    options.messages_per_second = Droonga::DataAbsorber::DEFAULT_MESSAGES_PER_SECOND
    options.progress_interval_seconds = Droonga::DataAbsorber::DEFAULT_PROGRESS_INTERVAL_SECONDS
    options.verbose = false
    parser = OptionParser.new
    parser.version = Droonga::Engine::VERSION

    parser.separator("")
    parser.separator("Connection:")
    parser.on("--source-host=HOST",
              "Host name of the source cluster to be connected.") do |host|
      options.source_host = host
    end
    parser.on("--destination-host=HOST",
              "Host name of this cluster to be connected.") do |host|
      options.destination_host = host
    end
    parser.on("--receiver-host=HOST",
              "Host name of this computer.",
              "(#{options.receiver_host})") do |host|
      options.receiver_host = host
    end
    parser.on("--port=PORT", Integer,
              "Port number of the source cluster to be connected.",
              "(#{options.port})") do |port|
      options.port = port
    end

    parser.separator("")
    parser.separator("Data:")
    parser.on("--tag=TAG",
              "Tag name to be used to communicate with Droonga system.",
              "(#{options.tag})") do |tag|
      options.tag = tag
    end
    parser.on("--dataset=DATASET",
              "Dataset to be absorbed.",
              "(#{options.dataset})") do |dataset|
      options.dataset = dataset
    end
    parser.on("--records-per-second=N", Integer,
              "Maximum number of records per second to be absorbed.",
              "'#{Droonga::Client::RateLimiter::NO_LIMIT}' means no limit.",
              "(#{options.messages_per_second})") do |n|
      options.messages_per_second = n
    end

    parser.separator("")
    parser.separator("Miscellaneous:")
    parser.on("--progress-interval-seconds=N", Integer,
              "Interval seconds to report progress.",
              "(#{options.progress_interval_seconds})") do |n|
      options.progress_interval_seconds = n
    end
    parser.on("--[no-]verbose",
              "Output details for internal operations.",
              "(#{options.verbose})") do |verbose|
      options.verbose = verbose
    end

    parser.parse!(ARGV)
    @options = options
  end

  def assert_valid_options
    unless @options.source_host
      raise "You must specify the source host via --source-host option."
    end
    unless @options.destination_host
      raise "You must specify the destination host via --destination-host option."
    end
  end

  def source_node
    "#{@options.source_host}:#{@options.port}/#{@options.tag}"
  end

  def destination_node
    "#{@options.destination_host}:#{@options.port}/#{@options.tag}"
  end

  def run_remote_command(target, command, options)
    serf = Droonga::Serf.new(target, :verbose => @options.verbose)
    serf.send_query(command, options)
  end

  def absorber
    @absorber ||= prepare_absorber
  end

  def prepare_absorber
    absorber_options = {
      :dataset          => @options.dataset,
      :source_host      => @options.source_host,
      :destination_host => @options.destination_host,
      :receiver_host    => @options.receiver_host,
      :port             => @options.port,
      :tag              => @options.tag,
      :messages_per_second => @options.messages_per_second,
      :progress_interval_seconds => @options.progress_interval_seconds,
      :client_options   => {
        :backend => :coolio,
        :loop    => @loop,
      },
    }
    Droonga::DataAbsorber.new(absorber_options)
  end

  def absorb
    last_progress = nil
    absorber.run do |progress|
      if last_progress
        printf("%s", "#{" " * last_progress[:message].size}\r")
      end
      printf("%s", "#{progress[:message]}\r")
      last_progress = progress
    end
    @loop.run

    if absorber.error_message
      puts(absorber.error_message)
      do_cancel
      return false
    end

    puts ""

    response = run_remote_command(source_node, "report_metadata",
                                  "node" => source_node,
                                  "key" => "last_processed_message_timestamp")
    timestamp = response["value"]
    if timestamp and not timestamp.empty?
      puts "The timestamp of the last processed message in the source node: #{timestamp}"
      puts "Setting effective message timestamp for the destination node..."
      response = run_remote_command(destination_node, "accept_messages_newer_than",
                                    "node" => destination_node,
                                    "timestamp" => timestamp)
    end
    true
  end

  def trap_signals
    trap(:TERM) do
      trap(:TERM, "DEFAULT")
      do_cancel
    end

    trap(:INT) do
      trap(:INT, "DEFAULT")
      do_cancel
    end

    trap(:QUIT) do
      trap(:QUIT, "DEFAULT")
      do_cancel
    end
  end

  def do_cancel
    #XXX we have to write more codes to cancel remote processes!
  end
end

AbsorbDataCommand.new.run
