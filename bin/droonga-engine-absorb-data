#!/usr/bin/env ruby
#
# Copyright (C) 2014 Droonga Project
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

require "ostruct"
require "optparse"
require "open3"
require "socket"

require "droonga/engine/version"
require "droonga/catalog_generator"
require "droonga/path"
require "droonga/data_absorber"
require "droonga/serf"
require "droonga/client"

class AbsorbDataCommand
  def run
    parse_options
    assert_valid_options
    trap_signals

    puts "Start to absorb data from #{@options.source_host}"
    puts "                       to #{@options.destination_host}"
    puts "                      via #{@options.receiver_host} (this host)"
    puts "  dataset = #{@options.dataset}"
    puts "  port    = #{@options.port}"
    puts "  tag     = #{@options.tag}"
    puts ""
    puts "Absorbing..."

    if @options.remote
      absorb_on_remote
    else
      absorb_on_local
    end

    puts "Done."
    exit(true)
  end

  private
  def parse_options
    options = OpenStruct.new
    options.port    = Droonga::CatalogGenerator::DEFAULT_PORT
    options.tag     = Droonga::CatalogGenerator::DEFAULT_TAG
    options.dataset = Droonga::CatalogGenerator::DEFAULT_DATASET
    options.remote  = true
    options.receiver_host = Socket.gethostname
    options.messages_per_second = Droonga::DataAbsorber::DEFAULT_MESSAGES_PER_SECOND
    parser = OptionParser.new
    parser.version = Droonga::Engine::VERSION

    parser.separator("")
    parser.separator("Connection:")
    parser.on("--source-host=HOST",
              "Host name of the source cluster to be connected.") do |host|
      options.source_host = host
    end
    parser.on("--destination-host=HOST",
              "Host name of this cluster to be connected.") do |host|
      options.destination_host = host
    end
    parser.on("--receiver-host=HOST",
              "Host name of this computer.",
              "(#{options.receiver_host})") do |host|
      options.receiver_host = host
    end
    parser.on("--port=PORT", Integer,
              "Port number of the source cluster to be connected.",
              "(#{options.port})") do |port|
      options.port = port
    end
    parser.on("--[no-]remote",
              "Run command in remote node or not.",
              "(#{options.remote})") do |remote|
      options.remote = remote
    end

    parser.separator("")
    parser.separator("Data:")
    parser.on("--tag=TAG",
              "Tag name to be used to communicate with Droonga system.",
              "(#{options.tag})") do |tag|
      options.tag = tag
    end
    parser.on("--dataset=DATASET",
              "Dataset to be absorbed.",
              "(#{options.dataset})") do |dataset|
      options.dataset = dataset
    end
    parser.on("--records-per-second=N", Integer,
              "Maximum number of records per second to be absorbed.",
              "'#{Droonga::Client::RateLimiter::NO_LIMIT}' means no limit.",
              "(#{options.messages_per_second})") do |n|
      options.messages_per_second = n
    end

    parser.parse!(ARGV)
    @options = options
  end

  def assert_valid_options
    unless @options.source_host
      raise "You must specify the source host via --source-host option."
    end
    unless @options.destination_host
      raise "You must specify the destination host via --destination-host option."
    end
  end

  def source_node
    "#{@options.source_host}:#{@options.port}/#{@options.tag}"
  end

  def destination_node
    "#{@options.destination_host}:#{@options.port}/#{@options.tag}"
  end

  def run_remote_command(target, command, options)
    serf = Droonga::Serf.new(nil, target)
    result = serf.send_query(command, options)
    #puts result[:result]
    puts result[:error] unless result[:error].empty?
    result[:response]
  end

  def absorber
    @absorber ||= prepare_absorber
  end

  def prepare_absorber
    absorber_options = {
      :dataset          => @options.dataset,
      :source_host      => @options.source_host,
      :destination_host => @options.destination_host,
      :receiver_host    => @options.receiver_host,
      :port             => @options.port,
      :tag              => @options.tag,
      :messages_per_second => @options.messages_per_second,
    }
    Droonga::DataAbsorber.new(absorber_options)
  end

  def absorb_on_remote
    start_time_in_seconds = Time.new.to_i
    run_remote_command(destination_node, "absorb_data",
                       "node"    => destination_node,
                       "source"  => @options.source_host,
                       "port"    => @options.port,
                       "tag"     => @options.tag,
                       "dataset" => @options.dataset,
                       "messages_per_second" => @options.messages_per_second)
    last_progress = ""
    while true
      sleep(3)
      response = run_remote_command(destination_node, "report_status",
                                    "node" => destination_node,
                                    "key" => "absorbing")
      if response
        absorbing = response["value"]
        break unless absorbing
      end

      progress = absorber.report_progress(start_time_in_seconds)
      if progress
        printf("%s", "#{" " * last_progress.size}\r")
        printf("%s", "#{progress}\r")
        last_progress = progress
      end
    end
    puts ""

    response = run_remote_command(source_node, "report_status",
                                  "node" => source_node,
                                  "key" => "last_processed_message_timestamp")
    timestamp = response["value"]
    if timestamp and not timestamp.empty?
      puts "The timestamp of the last processed message in the source node: #{timestamp}"
      puts "Setting effective message timestamp for the destination node..."
      response = run_remote_command(destination_node, "set_status",
                                    "node" => destination_node,
                                    "key" => "effective_message_timestamp",
                                    "value" => timestamp)
    end
  end

  def absorb_on_local
    last_progress = ""
    absorber.absorb do |live_status|
      if live_status[:progress]
        progress = live_status[:progress]
      else
        progress = live_status[:output]
      end
      printf("%s", "#{" " * last_progress.size}\r")
      printf("%s", "#{progress}\r")
      last_progress = progress
    end
    response = run_remote_command(source_node, "report_status",
                                  "node" => source_node,
                                  "key" => "last_processed_message_timestamp")
    timestamp = response["value"]
    puts "The timestamp of the last processed message in the source node: #{timestamp}"
    if timestamp and not timestamp.empty?
      status = NodeStatus.new
      status.set(:effective_message_timestamp, timestamp)
    end
  end

  def trap_signals
    trap(:TERM) do
      do_cancel
      trap(:TERM, "DEFAULT")
    end

    trap(:INT) do
      do_cancel
      trap(:INT, "DEFAULT")
    end

    trap(:QUIT) do
      do_cancel
      trap(:QUIT, "DEFAULT")
    end
  end

  def do_cancel
    #XXX we have to write more codes to cancel remote processes!
  end
end

AbsorbDataCommand.new.run
